# èµ›åšmummyï¼ˆdogeï¼‰
å½“ä½ è¿›è¡Œç–²åŠ³çš„ç¼–ç å·¥ä½œæ—¶ï¼Œç»ˆç«¯ä¸­å‡ºç°ä¸€åªå¯çˆ±çš„èµ›åšmummyï¼ˆdogeï¼‰ä¼šè®©ä½ æ„Ÿåˆ°è½»æ¾æ„‰å¿«ï¼å®ƒä¸ä»…èƒ½æ¸²æŸ“é«˜åˆ†è¾¨ç‡çš„å‡½æ•°å›¾åƒï¼Œè¿˜èƒ½ä¸ºä½ çš„ç¼–ç¨‹æ—¶å…‰å¢æ·»ä¸€ä¸ä¹è¶£ã€‚å¿«æ¥è¯•è¯•å§ï¼

when you are doing tiring coding work, having a cute cyber mummy (doge) appear in your terminal can make you feel relaxed and happy! It can not only render high-resolution function images but also add a touch of fun to your programming time. Give it a try!

<div align="center">
  <img src="./111.jpg" width="600" alt="æ¼”ç¤º">
</div>

<!-- Language toggle: click a summary to expand the language you want. -->
## ğŸ”€ Language / è¯­è¨€åˆ‡æ¢

<details>
<summary>ğŸ‡¨ğŸ‡³ ä¸­æ–‡ï¼ˆç‚¹æ­¤æŸ¥çœ‹ä¸­æ–‡è¯´æ˜ï¼‰</summary>

---

# èµ›åšmummyï¼ˆdogeï¼‰ â€” å¯ç”¨äºå®ç°ç»ˆç«¯æ¸²æŸ“é«˜åˆ†è¾¨ç‡çš„ä»»æ„å‡½æ•°å›¾åƒ ğŸ¶

èµ›åšmummyï¼ˆdogeï¼‰æ˜¯ä¸€ä¸ªè·¨å¹³å°ã€æ— å¤–éƒ¨ä¾èµ–çš„ C å·¥å…·ï¼Œæ—¨åœ¨åœ¨ç»ˆç«¯ä¸­ä»¥é«˜åˆ†è¾¨ç‡æ¸²æŸ“ä»»æ„å‡½æ•°ï¼ˆä¾‹å¦‚ z = f(x, y)ï¼‰ç”Ÿæˆçš„å›¾åƒã€‚é¡¹ç›®åŒæ—¶æ”¯æŒ TrueColor ä¸ ASCII æ··åˆç€è‰²ï¼Œæ–¹ä¾¿åœ¨ä¸åŒç»ˆç«¯ä¸Šå±•ç¤ºç»†èŠ‚ä¸è‰²å½©ã€‚

---

## æ¦‚è¿° ğŸ”

æ¸²æŸ“å™¨åœ¨ä¸€ä¸ªäºŒç»´åŒºåŸŸå†…é‡‡æ ·ï¼Œè¯„ä¼°é«˜åº¦å‡½æ•° z = f(x, y)ï¼Œå°†å¾—åˆ°çš„ 3D ç‚¹ç”¨é€è§†æŠ•å½±å’Œ z-buffer æŠ•å½±åˆ°ç»ˆç«¯ç©ºé—´ã€‚å®ƒç»“åˆ ASCII å­—ç¬¦å¯†åº¦ä¸ 24 ä½é¢œè‰²ï¼ˆTrueColorï¼‰æ¥äº§ç”Ÿå…·æœ‰æ·±åº¦å’Œå…‰ç…§æç¤ºçš„æ··åˆç€è‰²æ•ˆæœã€‚

é»˜è®¤æ›²é¢æ˜¯ä¸€ä¸ªå¤åˆé«˜æ–¯å‡½æ•°ï¼ˆç±»ä¼¼â€œå­ªç”Ÿå±±â€ï¼‰ï¼Œéå¸¸é€‚åˆå±•ç¤ºæ¢¯åº¦å’Œå…‰ç…§æ•ˆæœã€‚

---

## ä¸»è¦ç‰¹æ€§ âœ¨

- è‡ªé€‚åº”åˆ†è¾¨ç‡ï¼šæ ¹æ®ç»ˆç«¯å¤§å°è°ƒæ•´é‡‡æ ·å¯†åº¦ä»¥ä¿æŒæ¸…æ™°åº¦ã€‚
- TrueColor æ¸²æŸ“ï¼šä½¿ç”¨ ANSI 24-bit é¢œè‰²åºåˆ—è¾“å‡ºå¹³æ»‘æ¸å˜ã€‚
- æ··åˆç€è‰²ï¼šä½¿ç”¨ ASCII å­—ç¬¦æä¾›çº¹ç†/äº®åº¦æç¤ºï¼ŒåŒæ—¶ç”¨ RGB é¢œè‰²è¡¨ç°é«˜åº¦/æè´¨ã€‚
- è·¨å¹³å°ï¼šæ”¯æŒç±» Unixï¼ˆioctl + unistdï¼‰å’Œ Windowsï¼ˆWinAPI + è™šæ‹Ÿç»ˆç«¯å¤„ç†ï¼‰ã€‚
- é«˜æ€§èƒ½ï¼šä½¿ç”¨è‡ªå®šä¹‰ z-buffer ä¸ä¸€æ¬¡æ€§ç¼“å†²è¾“å‡ºï¼ˆfwriteï¼‰å‡å°‘é—ªçƒå¹¶æé«˜ååã€‚

---

## æ•°å­¦éƒ¨åˆ† ğŸ“

æ¸²æŸ“å™¨å¯è§†åŒ–çš„é«˜åº¦åœºä¸ºä¸¤ä¸ªé«˜æ–¯ç±»å³°å€¼çš„ç»„åˆï¼Œä»£ç ä¸­å®ç°ä¸ºï¼š

```
f(x, y) = exp(-r1^4 / 1000) + exp(-r2^4 / 1000)
        + 0.1 * exp(-r1^4) + 0.1 * exp(-r2^4)
```

å…¶ä¸­

```
r1^2 = (x - 4)^2 + (y - 4)^2
r2^2 = (x + 4)^2 + (y + 4)^2
```

è¦ç‚¹ï¼š
- `r1^4` è¡¨ç¤º `(r1^2)^2`ï¼›`/1000` çš„é¡¹ä½¿å³°æ›´å®½æ›´å¹³æ»‘ï¼Œ`0.1*exp(-r^4)` åˆ™åœ¨å³°é™„è¿‘æ·»åŠ æ›´çª„æ›´å°çš„ç»†èŠ‚ã€‚
- å¯¹å…‰ç…§è¿›è¡Œæ³•çº¿ä¼°è®¡æ—¶ä½¿ç”¨ä¸­å¿ƒå·®åˆ†ï¼Œæ³•çº¿ï¼ˆæœªå½’ä¸€åŒ–ï¼‰ä¸º `(-df_dx, -df_dy, 1)`ï¼Œè®°å¾—å½’ä¸€åŒ–åå†ç”¨äºæ¼«åå°„/é•œé¢åå°„è®¡ç®—ã€‚
- æŠ•å½±æ—¶å¸¸ç”¨çš„å‚æ•°åŒ…æ‹¬ `Z_SCALE`ï¼ˆé«˜åº¦ç¼©æ”¾ï¼‰ã€`K1`ï¼ˆæŠ•å½±å°ºåº¦ï¼‰å’Œ `camera_distance`ï¼ˆç›¸æœºè·ç¦»ï¼‰ï¼Œè¿™äº›å‚æ•°å¯ä»¥ä¸€èµ·è°ƒèŠ‚ä»¥å¢å¼ºç«‹ä½“æ„Ÿã€‚

---

## æ„å»ºä¸è¿è¡Œ ğŸ› 

### å…ˆå†³æ¡ä»¶

- GCCï¼ˆWindows ä¸‹å»ºè®®ä½¿ç”¨ MinGW-w64ï¼‰

### Linux / WSL

```bash
# ç¼–è¯‘ï¼ˆé“¾æ¥æ•°å­¦åº“ï¼‰
gcc main.c -o surface -lm
# è¿è¡Œ
./surface
```

### Windows (PowerShell / CMD)

```powershell
# ç¼–è¯‘
gcc main.c -o surface.exe
# è¿è¡Œ
.\surface.exe
```

æç¤ºï¼šä¸ºäº†è·å¾—æœ€ä½³è§†è§‰æ•ˆæœï¼Œè¯·å…¨å±è¿è¡Œã€è°ƒå°ç»ˆç«¯å­—ä½“å¹¶ä½¿ç”¨æ”¯æŒ TrueColor çš„ç»ˆç«¯ï¼ˆå¦‚ Windows Terminalï¼‰ã€‚

---

## è‡ªå®šä¹‰ ğŸ”§

- å‡ ä½•å½¢çŠ¶ï¼šä¿®æ”¹ `main.c` ä¸­çš„ `float func(float x, float y)`ã€‚
- é¢œè‰²æ–¹æ¡ˆï¼šä¿®æ”¹ `get_color` æˆ–ç›¸å…³çš„é¢œè‰²æ˜ å°„å‡½æ•°ã€‚
- å…‰ç…§ï¼šè°ƒæ•´å…‰æºä½ç½®ã€å¼ºåº¦æˆ–ç€è‰²æ¨¡å‹ï¼ˆç¯å¢ƒ/æ¼«åå°„/é•œé¢ï¼‰ã€‚
- é‡‡æ ·ä¸å°ºåº¦ï¼šä¿®æ”¹é‡‡æ ·èŒƒå›´/æ­¥é•¿ã€æŠ•å½±ç¼©æ”¾ `K1`ã€ç›¸æœºè·ç¦»ä¸ `Z_SCALE` æ¥æ§åˆ¶ç«‹ä½“æ„Ÿä¸æ€§èƒ½ã€‚

å»ºè®®ï¼šå¢åŠ  `K1` æˆ– `Z_SCALE`ï¼Œæˆ–å‡å° `camera_distance` å¯æ˜æ˜¾å¢å¼º 3D æ„Ÿï¼›å‡å° `STEP` å¯å¾—åˆ°æ›´å¹³æ»‘çš„è¡¨é¢ä½†ä¼šé™ä½å¸§ç‡ã€‚

---

## å®ç°ç»†èŠ‚ ğŸ§­

æ¸²æŸ“æµç¨‹æ¦‚è¿°ï¼š

1. ç½‘æ ¼æ‰«æï¼šåœ¨é…ç½®åŸŸå†…ä»¥ä¸€å®šæ­¥é•¿éå† (x, y)ã€‚
2. æ›²é¢è¯„ä¼°ï¼šè®¡ç®— z = f(x, y)ã€‚
3. æ³•çº¿ä¼°è®¡ï¼šä¸­å¿ƒå·®åˆ†å¾—åˆ° df_dxã€df_dyã€‚ 
4. å˜æ¢ï¼šå¯¹ 3D ç‚¹åšæ—‹è½¬ä»¥ç”ŸæˆåŠ¨ç”»è§†è§’ã€‚ 
5. æŠ•å½±ï¼šæ‰§è¡Œé€è§†æŠ•å½±å¹¶ä¹˜ä»¥ç¼©æ”¾å¸¸æ•°ã€‚ 
6. Z-bufferï¼šä¿æŒæ¯ä¸ªåƒç´ æœ€è¿‘ç‚¹ç”¨äºé®æŒ¡ã€‚ 
7. ç€è‰²ï¼šåŸºäºäº®åº¦é€‰æ‹© ASCII å­—ç¬¦ï¼ŒåŒæ—¶ç”¨ RGB é¢œè‰²è¡¨ç°é«˜åº¦ä¸å…‰ç…§ã€‚ 
8. è¾“å‡ºï¼šç”¨ ANSI åºåˆ—å’Œä¸€æ¬¡æ€§ç¼“å†²è¾“å‡ºæ•´å¸§ã€‚

---

## æˆªå›¾ä¸æ¼”ç¤º ğŸ–¼ï¸ğŸ¬

ç¤ºä¾‹ï¼š

<table>
  <tr>
    <td style="padding:8px">
      <img src="linux1.png" style="max-width:420px; width:100%; height:auto;" alt="Linux 1" />
      <div style="text-align:center; font-size:0.95em;">Linux â€” è§†è§’ A</div>
    </td>
    <td style="padding:8px">
      <img src="linux2.png" style="max-width:420px; width:100%; height:auto;" alt="Linux 2" />
      <div style="text-align:center; font-size:0.95em;">Linux â€” è§†è§’ B</div>
    </td>
  </tr>
  <tr>
    <td colspan="2" style="text-align:center; padding-top:10px;">
      <video src="linux3.mp4" controls style="max-width:640px; width:100%; height:auto;" poster="linux1.png">è§†é¢‘ä¸å¯ç”¨ï¼Œè¯·ä¸‹è½½ï¼š<a href="linux3.mp4">linux3.mp4</a></video>
    </td>
  </tr>
  <tr>
    <td style="padding:8px">
      <img src="windows1.png" style="max-width:420px; width:100%; height:auto;" alt="Windows 1" />
      <div style="text-align:center; font-size:0.95em;">Windows â€” è§†è§’ A</div>
    </td>
    <td style="padding:8px">
      <img src="windows2.jpg" style="max-width:420px; width:100%; height:auto;" alt="Windows 2" />
      <div style="text-align:center; font-size:0.95em;">Windows â€” è§†è§’ B</div>
    </td>
  </tr>
  <tr>
    <td colspan="2" style="text-align:center; padding-top:10px;">
      <img src="windows3.png" style="max-width:640px; width:100%; height:auto;" alt="Windows 3" />
      <div style="text-align:center; font-size:0.95em;">Windows â€” è§†è§’ C</div>
    </td>
  </tr>
</table>

---

## è®¸å¯è¯ ğŸ“

MIT è®¸å¯è¯ï¼ˆè¯¦è§ä»“åº“ä¸­çš„ `LICENSE`ï¼‰ã€‚

</details>

<details open>
<summary>ğŸ‡ºğŸ‡¸ English (click to view English documentation)</summary>

---

# Cyber Mummy (doge) â€” Terminal high-resolution function renderer ğŸ¶

Cyber Mummy (doge) is a cross-platform, dependency-free C utility designed to render high-resolution images of arbitrary functions (for example, z = f(x, y)) directly in the terminal. It supports TrueColor and a hybrid ASCII+RGB output mode so you can preserve fine detail and color across different terminal environments.

---

## Overview ğŸ”

This lightweight renderer scans a 2D domain, evaluates a height function $z = f(x, y)$, and projects the resulting 3D points into terminal space using perspective projection and a z-buffer. It blends ASCII character density with 24-bit color (TrueColor) to produce hybrid shading with depth and lighting cues.

The default surface is a composite Gaussian function that resembles "Twin Peaks", well-suited to demonstrate gradient shading and lighting.

---

## Key Features âœ¨

- Adaptive resolution: adjusts sampling density based on terminal size for sharp output across different window sizes and font settings.
- TrueColor rendering: outputs 24-bit RGB via ANSI escape sequences for smooth gradients.
- Hybrid shading: uses ASCII characters for texture/lighting cues and RGB colors for depth/material shading.
- Cross-platform: supports Unix-like systems (ioctl + unistd) and Windows (WinAPI + Virtual Terminal processing).
- High performance: uses a custom z-buffer and double-buffered frame output (via fwrite) to reduce flicker and increase throughput.

---

## The Math ğŸ“

The renderer visualizes a scalar height field z = f(x, y). The implementation uses a compact combination of two Gaussian-like peaks; written compactly this is:

```
f(x, y) = exp(-r1^4 / 1000) + exp(-r2^4 / 1000)
        + 0.1 * exp(-r1^4) + 0.1 * exp(-r2^4)
```

where `r1` and `r2` are radial distances from two centers:

```
r1^2 = (x - 4)^2 + (y - 4)^2
r2^2 = (x + 4)^2 + (y + 4)^2
```

Notes and intuition:
- `r1^4` means `(r1^2)^2`. The `/1000` in the first two terms makes those bumps broad and smooth; the `0.1 * exp(-r^4)` terms add small, narrow detail near the peaks.
- The combination produces two offset hills with smooth gradients â€” a good target for finite-difference normal estimation and lighting.

Normal estimation (for lighting)

To compute lighting we need a surface normal at each sampled (x, y). The code estimates partial derivatives with a centered finite difference using a small epsilon Îµ:

```
df_dx â‰ˆ (f(x + Îµ, y) - f(x - Îµ, y)) / (2Îµ)
df_dy â‰ˆ (f(x, y + Îµ) - f(x, y - Îµ)) / (2Îµ)
```

An (unnormalized) object-space normal is then

```
N = (-df_dx, -df_dy, 1)
```

Normalize `N` before using it in dot products for diffuse/specular lighting. Recommended Îµ values are small but not too tiny â€” typical choices are in the range 1e-2 .. 2e-1 depending on sampling `STEP` (match Îµ roughly to your sampling distance to avoid numerical noise).

Projection and common constants

After computing the 3D point (x, y, z = f(x,y)), the renderer typically
1) optionally scales the height: z' = z * Z_SCALE,
2) applies rotations (pitch/yaw) to x,y,z', and
3) performs a simple perspective projection. A common projection form used in this project is:

```
ooz = 1.0 / (z_rotated + camera_distance)
xp = X_CENTER + K1 * ooz * x_rotated
yp = Y_CENTER - K1 * ooz * y_rotated
```

where `K1` is a projection scale, `camera_distance` avoids division by zero and controls perspective strength, and `(X_CENTER, Y_CENTER)` are the terminal's center coordinates.

Tuning for stronger 3D effect

- Increase `Z_SCALE` to exaggerate vertical differences.
- Increase `K1` to amplify projected offsets on screen.
- Decrease `camera_distance` to strengthen perspective (but beware of clipping when camera_distance is too small).
- Reduce sampling `STEP` for a finer mesh (costs CPU). Keep the finite-difference Îµ on the same order as `STEP` for stable normals.

See `main.c` for the exact constants and sampling domain used in your build. Adjust the constants there to experiment with the visual effect.

---

## Build & Run ğŸ› 

### Prerequisites

- GCC (MinGW-w64 on Windows, standard GCC on Linux/WSL)

### Linux / WSL

```bash
# Compile (link math library)
gcc main.c -o surface -lm
# Run
./surface
```

### Windows (PowerShell / CMD)

```powershell
# Compile
gcc main.c -o surface.exe
# Run
.\surface.exe
```

Tip: For the best visual result, run in full-screen, lower the terminal font size (Ctrl + Scroll), and use a TrueColor-capable terminal emulator.

---

## Customization ğŸ”§

- Geometry: edit `float func(float x, float y)` in `main.c` to render different surfaces.
- Color scheme: adjust the color-mapping function (e.g. `get_color` or `get_hybrid_color`) to change palettes.
- Lighting: change light position/intensity or shading model (ambient/diffuse/specular) to alter surface appearance.
- Sampling and scale: tweak sampling range/step, projection scale (K1), camera distance, and z-scale to increase/decrease perceived depth and smoothness.

Suggested knobs to tweak for stronger 3D effect:
- Increase projection scale (K1) and z-scale to exaggerate depth.
- Decrease camera distance to bring the surface closer to the camera.
- Reduce sampling `STEP` for a finer mesh (at the cost of performance).

---

## Implementation Details ğŸ§­

Rendering pipeline summary:

1. Grid scanning: iterate (x, y) over a configurable domain with a step size (sampling density).
2. Surface evaluation: compute $z = f(x, y)$.
3. Normal estimation: finite differences (central difference) to get surface normals for lighting.
4. Transform: rotate the 3D point (pitch & yaw) to create animation and different views.
5. Projection: project rotated 3D points into 2D terminal coordinates using perspective
   (typically multiplying by a constant and dividing by $z$ + camera distance).
6. Z-buffering: keep the nearest point per cell to handle occlusion.
7. Shading: combine ASCII character selection (by brightness) and RGB color (by height + lighting).
8. Output: build a single frame string with ANSI color escapes and write with `fwrite`.

---

## Tips & Troubleshooting ğŸ›Ÿ

- If colors look wrong on Windows CMD, ensure Virtual Terminal processing is enabled or use a terminal that supports TrueColor (Windows Terminal, ConEmu, etc.).
- For slow machines, increase `STEP` to reduce sample count or reduce terminal size.
- If the surface clips or appears too flat, increase `Z_SCALE` or reduce `CAMERA_DIST`.

---

## Screenshots & Demo ğŸ–¼ï¸ğŸ¬

Examples:

<table>
  <tr>
    <td style="padding:8px">
      <img src="linux1.png" style="max-width:420px; width:100%; height:auto;" alt="Linux 1" />
      <div style="text-align:center; font-size:0.95em;">Linux â€” view A</div>
    </td>
    <td style="padding:8px">
      <img src="linux2.png" style="max-width:420px; width:100%; height:auto;" alt="Linux 2" />
      <div style="text-align:center; font-size:0.95em;">Linux â€” view B</div>
    </td>
  </tr>
  <tr>
    <td colspan="2" style="text-align:center; padding-top:10px;">
      <video src="linux3.mp4" controls style="max-width:640px; width:100%; height:auto;" poster="linux1.png">Video not available, download: <a href="linux3.mp4">linux3.mp4</a></video>
    </td>
  </tr>
  <tr>
    <td style="padding:8px">
      <img src="windows1.png" style="max-width:420px; width:100%; height:auto;" alt="Windows 1" />
      <div style="text-align:center; font-size:0.95em;">Windows â€” view A</div>
    </td>
    <td style="padding:8px">
      <img src="windows2.jpg" style="max-width:420px; width:100%; height:auto;" alt="Windows 2" />
      <div style="text-align:center; font-size:0.95em;">Windows â€” view B</div>
    </td>
  </tr>
  <tr>
    <td colspan="2" style="text-align:center; padding-top:10px;">
      <img src="windows3.png" style="max-width:640px; width:100%; height:auto;" alt="Windows 3" />
      <div style="text-align:center; font-size:0.95em;">Windows â€” view C</div>
    </td>
  </tr>
</table>

---

## License ğŸ“

Distributed under the MIT License. See `LICENSE` for details.

</details>
